# 2023 - LambdaConcept - po@lambdaconcept.com

import os
import sys
import jinja2
import textwrap
import importlib.util
from collections import defaultdict

from amaranth import *
from amaranth.hdl import ir
from amaranth.back.verilog import convert_fragment

from ..interface import stream


__all__ = ["amaranth_to_litex"]


# adapted from https://github.com/amaranth-lang/amaranth/blob/main/amaranth/back/verilog.py
def convert(elaboratable, name="top", platform=None, ports=None, *, emit_src=True,
            strip_internal_attrs=False, return_fragment=False, **kwargs):
    fragment = ir.Fragment.get(elaboratable, platform).prepare(ports=ports, **kwargs)
    verilog_text, name_map = convert_fragment(fragment, name, emit_src=emit_src,
                                              strip_internal_attrs=strip_internal_attrs)
    if return_fragment:
        return verilog_text, fragment

    return verilog_text


def get_ports(elaboratable):
    # Iterate over the elaboratable object to get the list of ports to be
    # exported to the verilog generator.
    # Also records important information inside the metadata dict for later
    # to help reconstruct the python wrapper.

    ports = []
    metadata = defaultdict(dict)

    for key, value in elaboratable.__dict__.items():
        print(key, type(value), value)

        if isinstance(value, Signal):
            ports.append(value)
            metadata["signals"][key] = value

        elif isinstance(value, stream.Endpoint):
            for name, _, _ in value.layout:
                field = value[name]

                # valid, ready, first, last
                if isinstance(field, Signal):
                    ports.append(field)
                    metadata["duid"][field.duid] = "{}.{}".format(key, name)

                # payload
                elif isinstance(field, Record):
                    for subname, _, _ in field.layout:
                        subfield = field[subname]

                        ports.append(subfield)
                        metadata["duid"][subfield.duid] = "{}.{}".format(key, subname)

            metadata["endpoints"][key] = value

    return ports, metadata


def get_endpoint_description(endpoint):
    desc = []
    for name, shape, _ in endpoint.payload.layout:
        desc.append("({!r}, {!r})".format(name, shape))
    return "[{}]".format(", ".join(desc))


def import_pyfile(name, filename):
    spec = importlib.util.spec_from_file_location(name, filename)
    module = importlib.util.module_from_spec(spec)
    sys.modules[name] = module
    spec.loader.exec_module(module)
    return module


def gen_litex(fragment, metadata, name=None, output_dir=None):
    if output_dir is None:
        output_dir = ""

    params = {}
    print(metadata["duid"])

    # iterate over the instance ports and recreate the mapping
    for sig, direction in fragment.ports.items():

        if sig.name == "clk":
            value = "ClockSignal()"
        elif sig.name == "rst":
            value = "ResetSignal()"
        else:
            value = "self." + metadata["duid"][sig.duid]

        key = "{}_{}".format(direction, sig.name)
        params[key] = value


    template = """
# Automatically generated by amaranth_to_litex. Do not edit.
import os

from migen import *

from litex.soc.interconnect import stream

class {{classname}}(Module):
    def __init__(self, platform):

        # Signals
    {% for sig in signals.values() %}
        self.{{sig.name}} = Signal({{sig.width}})
    {% endfor %}

        # Endpoints
    {% for name, ep in endpoints.items() %}
        self.{{name}} = stream.Endpoint({{get_endpoint_description(ep)}})
    {% endfor %}

        # # #

        params = dict(
        {% for k, v in params.items() %}
            {{k}} = {{v}},
        {% endfor %}
        )
        self.specials += Instance("{{instancename}}", **params)

        if platform is not None:
            platform.add_source(os.path.join("{{output_dir}}", "{{instancename}}.v"), "verilog")
"""

    source = textwrap.dedent(template).strip()
    compiled = jinja2.Template(source, trim_blocks=True, lstrip_blocks=True)
    output = compiled.render(dict(
        classname=name,
        instancename=name,
        output_dir=output_dir,
        signals=metadata["signals"],
        endpoints=metadata["endpoints"],
        params=params,

        # utility functions
        get_endpoint_description=get_endpoint_description,
    ))

    # write python file
    filename = os.path.join(output_dir, name + ".py")
    with open(filename, "w") as f:
        f.write(output)

    # import python file
    module = import_pyfile(name, filename)
    return getattr(module, name)


def gen_verilog(elaboratable, name=None, output_dir=None):
    ports, metadata = get_ports(elaboratable)
    print("ports", ports)
    ver, frag = convert(elaboratable, name=name, ports=ports,
                      emit_src=False, return_fragment=True)

    # write verilog file
    filename = os.path.join(output_dir, name + ".v")
    with open(filename, "w") as f:
        f.write(ver)

    return frag, metadata


def amaranth_to_litex(platform, elaboratable, name=None, output_dir=None):
    if name is None:
        name = elaboratable.__class__.__name__
    if output_dir is None:
        output_dir = "build"

    fragment, metadata = gen_verilog(elaboratable, name=name, output_dir=output_dir)
    cls = gen_litex(fragment, metadata, name=name, output_dir=output_dir)

    return cls(platform)


if __name__ == "__main__":
    from ..cores.counter import *

    ctr = Counter(width=24)
    amaranth_to_litex(None, ctr, name=None, output_dir="")
